/* Description of Platypus Service APIs and message types */
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.apache.platypus.server.grpc";
option java_outer_classname = "LuceneServerProto";
option objc_class_prefix = "HLW";

package luceneserver;

// The LuceneServer service definition.
service LuceneServer {
    /* Create an Index */
    rpc createIndex (CreateIndexRequest) returns (CreateIndexResponse) {
    }
    /* Change global offline or online settings for this index. */
    rpc liveSettings (LiveSettingsRequest) returns (LiveSettingsResponse) {
    }
    /* Registers one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).
      Pass a list of Fields and an indexName. Any number of fields may be registered in a single request,
      and once a field is registered it cannot be changed (write-once).
      This returns the full set of fields currently registered. */
    rpc registerFields (FieldDefRequest) returns (FieldDefResponse) {
    }
    /* Change global offline settings for this index.
    This returns the currently set settings; pass no settings changes to retrieve current settings.*/
    rpc settings (SettingsRequest) returns (SettingsResponse) {
    }
    /* Starts an index */
    rpc startIndex (StartIndexRequest) returns (StartIndexResponse) {
    }
    /* Stops an index */
    rpc stopIndex (StopIndexRequest) returns (DummyResponse) {
    }
    /* Adds a stream of Documents */
    rpc addDocuments (stream AddDocumentRequest) returns (AddDocumentResponse) {
    }
    /* Refresh the latest searcher for an index */
    rpc refresh (RefreshRequest) returns (RefreshResponse) {
    }
    /* Commits all pending changes to durable storage*/
    rpc commit (CommitRequest) returns (CommitResponse) {
    }
    /* Retrieve index statistics*/
    rpc stats (StatsRequest) returns (StatsResponse) {
    }
    /* Search */
    rpc search (SearchRequest) returns (SearchResponse) {
    }
    /* Delete documents */
    rpc delete (AddDocumentRequest) returns (AddDocumentResponse) {
    }
    /* Delete all documents for index */
    rpc deleteAll (DeleteAllDocumentsRequest) returns (DeleteAllDocumentsResponse) {
    }
    /* Delete index */
    rpc deleteIndex (DeleteIndexRequest) returns (DeleteIndexResponse) {
    }

}

//The ReplicationServer service definition.
service ReplicationServer {
    /* Issued by replica on primary node when it comes up */
    rpc addReplicas (AddReplicaRequest) returns (AddReplicaResponse) {
    }
    /* Issued by replica to receive CopyState from primary */
    rpc recvCopyState (CopyStateRequest) returns (CopyState) {
    }
    /* Send a file as a stream in chunks*/
    rpc sendRawFile (stream RawFileChunk) returns (TransferStatus) {
    }
    /* Receives a file as a stream in chunks. Typically issued by replica on primary */
    rpc recvRawFile (FileInfo) returns (stream RawFileChunk) {
    }
    /* Issued by primary on replica to inform it to start copying files either pre-warming (new merged segments) or when replica comes up first time */
    rpc copyFiles (CopyFiles) returns (stream TransferStatus) {
    }
    /* Invoked externally to replica, to notify it that a new NRT point was just created on the primary */
    rpc newNRTPoint (NewNRTPoint) returns (TransferStatus) {
    }
    /** Invoked externally to primary, to make all recent index operations searchable on the primary and, once copying is done, on the replicas */
    rpc writeNRTPoint (IndexName) returns (SearcherVersion) {
    }
    /** Invoked externally to replica, to get the current Searcher version on replica. Typically used to check i */
    rpc getCurrentSearcherVersion (IndexName) returns (SearcherVersion) {
    }

}

/* Input to createIndex */
message CreateIndexRequest {
    string indexName = 1; // name of the index to be created. [a-zA-Z0-9]*
    string rootDir = 2; //rootDirectory that maintains all state files for durability.
}

/* Response from Server to createIndex */
message CreateIndexResponse {
    string response = 1;
}

/* Input to liveSettings */
message LiveSettingsRequest {
    string indexName = 1; // name of index whose liveSettings are to be updated.
    //Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen).
    double maxRefreshSec = 2;
    //Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen).
    double minRefreshSec = 3;
    //Non-current searchers older than this are pruned.
    double maxSearcherAgeSec = 4;
    //Size (in MB) of IndexWriter's RAM buffer.
    double indexRamBufferSizeMB = 5;
}

/* Response from Server to liveSettings */
message LiveSettingsResponse {
    string response = 1;
}

//Type of the field
enum FieldType {
    ATOM = 0; // Text that's indexed as a single token, with DOCS_ONLY and omitting norms.
    TEXT = 1; // Text that's tokenized and indexed, with the index-time analyzer.
    BOOLEAN = 2; // Boolean value.
    LONG = 3; //Long value.
    INT = 4; // Int value.
    DOUBLE = 5; //Double value.
    FLOAT = 6; // Float value.
    LAT_LON = 7; // A latitude/longitude point.
    DATE_TIME = 8; // Date and optional time.
    // TODO name this "dynamic" instead of "virtual"?
    VIRTUAL = 9; // Virtual field defined with a JavaScript expression.
    // TODO need tests for internal:
    INTERNAL = 10; //Internal field, currently only for holding indexed facets data.
}

//How the tokens should be indexed.
enum IndexOptions {
    DOCS_FREQS_POSITIONS = 0; // Index doc ids, term frequencies and positions.
    DOCS = 1; // Index only doc ids (for binary search).
    DOCS_FREQS = 2; // Index doc ids and term frequencies.
    DOCS_FREQS_POSITIONS_OFFSETS = 3; // Index doc ids, term frequencies, positions and offsets.
}

//Whether/how term vectors should be indexed.
enum TermVectors {
    NO_TERMVECTORS = 0; // no term vectors are indexed
    TERMS = 1; // Index terms and freqs only.
    TERMS_POSITIONS = 2; // Index terms, freqs and positions.
    TERMS_POSITIONS_OFFSETS = 3; // Index terms, freqs, positions and offsets.
    TERMS_POSITIONS_OFFSETS_PAYLOADS = 4; // Index terms, freqs, positions, offsets and payloads
}

//Whether/How this field should index facets, and how.
enum FacetType {
    NO_FACETS = 0; //No facets are indexed.
    FLAT = 1; //Facets are indexed with no hierarchy.
    HIERARCHY = 2; //Facets are indexed and are hierarchical.
    NUMERIC_RANGE = 3; //Compute facet counts for custom numeric ranges
    SORTED_SET_DOC_VALUES = 4; //"Use SortedSetDocValuesFacetCounts, which must be flat but don't require a taxonomy index
}

message Field {
    string name = 1; // name of the field
    FieldType type = 2;
    bool search = 3; // True if the value should be available for searching (or numeric range searching, for a numeric field).
    bool store = 4; // True if the value should be stored.
    bool storeDocValues = 5; // Whether to index the value into doc values.
    bool sort = 6; // True if the value should be indexed into doc values for sorting.
    bool tokenize = 7; // True if the value should be tokenized.
    bool group = 8; // True if the value should be indexed into doc values for grouping.
    bool multiValued = 9; // True if this field may sometimes have more than one value.
    bool highlight = 10; // True if the value should be indexed for highlighting.
    bool omitNorms = 11; // True if norms are omitted.
    string dateTimeFromat = 12; // Format string used to parse datetime fields
    string postingsFormat = 13; // Which PostingsFormat should be used to index this field.
    string docValuesFormat = 14; // Which DocValuesFormat should be used to index this field.
    IndexOptions indexOptions = 15; //How the tokens should be indexed.
    string expression = 16; // The JavaScript expression defining a virtual field's value (only used with type=virtual).
    //TODO make analyzers message types i.e. StandardAnalyzer, EnglishAnalyzer, CustomAnalyzer etc
    string analyzer = 17; // Analyzer to use for this field during indexing and searching.
    string indexAnalyzer = 18; // Analyzer to use for this field during indexing.
    string searchAnalyzer = 19; //Analyzer to use for this field during searching.
    TermVectors termVectors = 20; // Whether/how term vectors should be indexed.
    //TODO make similarity message types i.d. DefaultSimilarity, CustomSimilarity, BM25Similarity;
    string similarity = 21; // Which Similarity implementation to use for this field.
    FacetType facet = 22; // Whether this field should index facets, and how.
    string facetIndexFieldName = 23; // "Which underlying Lucene index field is used to hold any indexed taxonomy or sorted set doc values facets

}

/* Input to registerFields */
message FieldDefRequest {
    string indexName = 1; // name of the index against which the field is to be created
    repeated Field field = 2;
}

/* Response from Server for registerFields */
message FieldDefResponse {
    string response = 1;
}

/* Input to settings */
message SettingsRequest {
    string indexName = 1; // Index name
    double mergeMaxMBPerSec = 2; // Rate limit merges to at most this many MB/sec
    double nrtCachingDirectoryMaxMergeSizeMB = 3; // Largest merged segment size to cache in RAMDirectory, default: 5.0MB
    double nrtCachingDirectoryMaxSizeMB = 4; // Largest overall size for all files cached in NRTCachingDirectory; set to -1 to disable NRTCachingDirectory default: 60.0MB
    int32 concurrentMergeSchedulerMaxThreadCount = 5; // How many merge threads to allow at once
    int32 concurrentMergeSchedulerMaxMergeCount = 6; // Maximum backlog of pending merges before indexing threads are stalled
    SortFields indexSort = 7; // Index time sorting; can only be written once", SearchHandler.SORT_TYPE
    bool indexVerbose = 8; // Turn on IndexWriter's infoStream (to stdout)
    bool indexMergeSchedulerAutoThrottle = 9; // Turn on/off the merge scheduler's auto throttling
    string normsFormat = 10; // Which NormsFormat should be used for all indexed fields. default: Lucene80NormsFormat
    /* Base Directory implementation to use (NRTCachingDirectory will wrap this);
    either one of the core implementations (FSDirectory, MMapDirectory, NIOFSDirectory, SimpleFSDirectory,
    RAMDirectory (for temporary indices!) or a fully qualified path to a Directory implementation that has a
    public constructor taking a single File argument default: FSDirectory */
    string directory = 11;

}

/* Settings Response returned from Server */
message SettingsResponse {
    string response = 1;
}

/* Fields to sort on either during index time or search time*/
message SortFields {
    repeated SortType sortedFields = 1;
}

/* "The field to sort on. Pass <code>docid</code> for index order and <code>score</code> for relevance sort. */
message SortType {
    string fieldName = 1; // name of field to sort
    Selector selector = 2; // For multi valued fields, how to select which value is used for sorting
    Point origin = 3; // For distance sort, the point that we measure distance from
    /* Whether missing values should sort last instead of first.
    Note that this runs \"before\" reverse, so if you sort missing first and reverse=true then missing values will
    be at the end.*/
    bool missingLat = 4;
    // Sort in reverse of the field's natural order
    bool reverse = 5;
}

/* For multi valued fields, how to select which value is used for sorting */
enum Selector {
    MIN = 0; // Minimum value
    MAX = 1; // Maximum value
    MIDDLE_MIN = 2; // Middle value of the set; if there are an even number of values, the lower of the middle two is chosen
    MIDDLE_MAX = 3; // Middle value of the set; if there are an even number of values, the upper of the middle two is chosen
}

/* Point representation */
message Point {
    double latitude = 1; // Latitude of the point
    double longitude = 2; // Longitude of the point
}

/* Start the index */
message StartIndexRequest {
    string indexName = 1; //index name
    Mode mode = 2; //Standalone, NRT primary or replica mode to start this index.
    int64 primaryGen = 3; //primary, the generation of this primary (should increment each time a new primary starts for this index)
    string primaryAddress = 4; //replica, the IP address or host name of the remote primary
    int32 port = 5; //replica, the TCP port of the remote primary
}

enum Mode {
    STANDALONE = 0;
    PRIMARY = 1;
    REPLICA = 2;
}

message StartIndexResponse {
    int32 maxDoc = 1; //one greater than the largest possible document number
    int32 numDocs = 2; //the number of documents in this index.
    string segments = 3; //string representation of the IndexReader implementation
    double startTimeMS = 4; //time taken to start the index
}

message AddDocumentRequest {
    string indexName = 1; //name of the index
    //we use this wrapper object to represent each field as a multivalued field.
    message MultiValuedField {
        repeated string value = 1; //list of values for this field
    }
    map<string, MultiValuedField> fields = 3; //map of field name to a list of string values.
}

message AddDocumentResponse {
    string genId = 1;
}

message RefreshRequest {
    string indexName = 1; //index name to be refreshed
}

message RefreshResponse {
    double refreshTimeMS = 1; //time taken in milliseconds to refresh the index
}

message CommitRequest {
    string indexName = 1; //index to commit
}

message CommitResponse {
    /*  sequence number of the last operation in the commit.  All sequence numbers less than this value
    will be reflected in the commit, and all others will not.*/
    int64 gen = 1;
}

message StatsRequest {
    string indexName = 1; //retrieve stats of the index
}

message StatsResponse {
    int32 ord = 1; //shard ordinal
    /* The total number of docs in this index, including docs not yet flushed (still in the RAM buffer),
    not counting deletions.*/
    int32 maxDoc = 2;
    /**
     * The total number of docs in this index, including
     * docs not yet flushed (still in the RAM buffer), and
     * including deletions. NOTE: buffered deletions
     * are not counted.  If you really need these to be
     * counted you should call {@link IndexWriter#commit()} first.
     */
    int32 numDocs = 3;
    string state = 4; //state of the index
    Taxonomy taxonomy = 5; //Taxonomy(facets) stats
    repeated Searcher searchers = 6; //Searcher stats
    Searcher currentSearcher = 7; //Current Searcher stats
}

message Taxonomy {
    int32 numOrds = 1; //number of docs in this taxonomy reader
    string segments = 2; //string representation of segments
}

message Searcher {
    /* the version recorded in the commit that the reader opened.
    This version is advanced every time a change is made with IndexWriter.*/
    int64 version = 1;
    int32 numDocs = 2; //total number of docs in this index
    string segments = 3; //string representation of segments
    double staleAgeSeconds = 4; //how much time has passed since this searcher was the current (live) searcher
}

message SearchRequest {
    string indexName = 1; //index to search against
    int32 startHit = 2; // Which hit to start from (for pagination); default: 0
    int32 topHits = 3; // How many top hits to retrieve; default: 10
    /* Maximum number of seconds spent on each collection phase; note that for
     * multi-pass searches (e.g. query-time grouping), this timeout applies to each phase. */
    double timeoutSec = 4;
    repeated string retrieveFields = 5; //Which fields to highlight or retrieve.
    string queryText = 6; //Query text to parse using the specified QueryParser.
    repeated VirtualField virtualFielsd = 7; //Defines virtual fields (name'd dynamic expressions) for this query.
    string query = 8; //TODO: not implemented. Full query to execute using QueryNodes
    QuerySortField querySort = 9; //Sort hits by field (default is by relevance).
}

message SearchResponse {
    string response = 1; //search response; TODO: dont be lazy, return a structured format not a jsonString
}

/* Virtual field used during search */
message VirtualField {
    string expression = 1; // JavaScript expression defining this field's values.
    string name = 2; // Virtual field's name. Must be different from registered fields and any other virtual fields.
}

message QuerySortField {
    bool doDocScores = 1; //Compute the doc score for each collected (costs added CPU); default:false
    bool doMaxScore = 2; //Compute the max score across all hits (costs added CPU); default: false
    SortFields fields = 3; //List of Fields to sort on.
}

message DeleteAllDocumentsRequest {
    string indexName = 1; //index to delete all documents  from
}

message DeleteAllDocumentsResponse {
    string genId = 1; //Returns the index generation (indexGen) that reflects the deletion.
}

message DeleteIndexRequest {
    string indexName = 1; //index to delete
}

message DeleteIndexResponse {
    string ok = 1; //Returns "ok" string on  success
}

message DummyResponse {
    string ok = 1; // returns "ok" string on success
}

message StopIndexRequest {
    string indexName = 1; //index name to stop
}

message AddReplicaRequest {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
    int32 replicaId = 3; //replica Id
    string hostName = 4; // replica host name
    int32 port = 5; // replica port number
}

message AddReplicaResponse {
    string ok = 1; //Returns "ok" string on  success
}

/* Holds incRef'd file level details for one point-in-time segment infos on the primary node. */
message CopyState {
    int32 infoBytesLength = 1; // infoBytes len
    bytes infoBytes = 2; //infoBytes
    int64 gen = 3; //gen
    int64 version = 4; //versiom
    FilesMetadata filesMetadata = 5; //fileMetadata
    int32 completedMergeFilesSize = 6; //completed merged files
    repeated string completedMergeFiles = 7; //names of files that finished merge
    int64 primaryGen = 8; //primary Gen
}

message FilesMetadata {
    int32 numFiles = 1; //number of files int this set
    repeated FileMetadata fileMetadata = 2; //list of metadata for each file
}

message FileMetadata {
    string fileName = 1; //file Name
    int64 len = 2; //file checksum
    int64 checksum = 3; //file checksum
    int32 headerLength = 4; //file header length;
    bytes header = 5; //file header;
    int32 footerLength = 6; //file header length;
    bytes footer = 7; //file header;
}

/** Primary invokes this on a replica to ask it to copy files */
message CopyFiles {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
    int64 primaryGen = 3; //primary, the generation of this primary (should increment each time a new primary starts for this index)
    FilesMetadata filesMetadata = 4; //file metadata to copy
}

/** Replica invokes this on a primary to let primary know it needs the CopyState */
message CopyStateRequest {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
    int32 replicaId = 3; //replica Id
}

message FilesInfo {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
    int32 replicaId = 3; //replica Id
    repeated FileInfo fileInfo = 4; //list of file name and offsets from where primary should start sending bytes to replica
}

message FileInfo {
    string fileName = 1; // Name of the file the replica wants primary to send
    int64 fpStart = 2; // Starting offset in the file primary should start sending bytes from:
    string indexName = 3; //index name these files belong to
}

message RawFileChunk {
    bytes content = 1; //raw contents of file
}

enum TransferStatusCode {
    Unknown = 0;
    Done = 1;
    Failed = 2;
    Ongoing = 3;
}

message TransferStatus {
    string Message = 1;
    TransferStatusCode Code = 2;
}

message NewNRTPoint {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
    int64 primaryGen = 3; //primary, the generation of this primary (should increment each time a new primary starts for this index)
    int64 version = 4; //version number when this SegmentInfos was generated
}

message IndexName {
    int32 magicNumber = 1; //magic number send on all requests since these are meant for internal communication only
    string indexName = 2; //index name
}

message SearcherVersion {
    int64 version = 1; //returns the version recorded in the commit that the reader opened.  This version is advanced every time a change is made with IndexWriter
    bool didRefresh = 2; //true if refresh happened
}